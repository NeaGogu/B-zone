/*
 * Bumbal Client Api
 *
 * Bumbal API documentation
 *
 * API version: 2.0
 * Contact: info@bumbal.eu
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ActivityApiService ActivityApi service
type ActivityApiService service

type ApiBulkUpdateActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	body *ActivityBulkUpdateArguments
}

func (r ApiBulkUpdateActivityRequest) Body(body ActivityBulkUpdateArguments) ApiBulkUpdateActivityRequest {
	r.body = &body
	return r
}

func (r ApiBulkUpdateActivityRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.BulkUpdateActivityExecute(r)
}

/*
 * BulkUpdateActivity Update multiple activities
 * Update multiple activities
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiBulkUpdateActivityRequest
 */
func (a *ActivityApiService) BulkUpdateActivity(ctx _context.Context) ApiBulkUpdateActivityRequest {
	return ApiBulkUpdateActivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) BulkUpdateActivityExecute(r ApiBulkUpdateActivityRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.BulkUpdateActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/bulk-update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDeleteActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	activityId int64
}


func (r ApiDeleteActivityRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DeleteActivityExecute(r)
}

/*
 * DeleteActivity Delete an activity
 * Delete an activity
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activityId ID of the activity to delete
 * @return ApiDeleteActivityRequest
 */
func (a *ActivityApiService) DeleteActivity(ctx _context.Context, activityId int64) ApiDeleteActivityRequest {
	return ApiDeleteActivityRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) DeleteActivityExecute(r ApiDeleteActivityRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.DeleteActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", _neturl.PathEscape(parameterToString(r.activityId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiLockActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	filters *ActivityFiltersModel
}

func (r ApiLockActivityRequest) Filters(filters ActivityFiltersModel) ApiLockActivityRequest {
	r.filters = &filters
	return r
}

func (r ApiLockActivityRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.LockActivityExecute(r)
}

/*
 * LockActivity Lock activities which satisfy set filters
 * Lock activities which satisfy set filters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiLockActivityRequest
 */
func (a *ActivityApiService) LockActivity(ctx _context.Context) ApiLockActivityRequest {
	return ApiLockActivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) LockActivityExecute(r ApiLockActivityRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.LockActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.filters == nil {
		executionError.error = "filters is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiLockActivityOnRouteRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	filters *ActivityFiltersModel
}

func (r ApiLockActivityOnRouteRequest) Filters(filters ActivityFiltersModel) ApiLockActivityOnRouteRequest {
	r.filters = &filters
	return r
}

func (r ApiLockActivityOnRouteRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.LockActivityOnRouteExecute(r)
}

/*
 * LockActivityOnRoute Lock activities on route which satisfy set filters
 * Lock activities on route which satisfy set filters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiLockActivityOnRouteRequest
 */
func (a *ActivityApiService) LockActivityOnRoute(ctx _context.Context) ApiLockActivityOnRouteRequest {
	return ApiLockActivityOnRouteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) LockActivityOnRouteExecute(r ApiLockActivityOnRouteRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.LockActivityOnRoute")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/lock-on-route"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.filters == nil {
		executionError.error = "filters is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiLockActivityOnRouteAndTimeRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	filters *ActivityFiltersModel
}

func (r ApiLockActivityOnRouteAndTimeRequest) Filters(filters ActivityFiltersModel) ApiLockActivityOnRouteAndTimeRequest {
	r.filters = &filters
	return r
}

func (r ApiLockActivityOnRouteAndTimeRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.LockActivityOnRouteAndTimeExecute(r)
}

/*
 * LockActivityOnRouteAndTime Lock activities on route and time which satisfy set filters
 * Lock activities on route and time which satisfy set filters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiLockActivityOnRouteAndTimeRequest
 */
func (a *ActivityApiService) LockActivityOnRouteAndTime(ctx _context.Context) ApiLockActivityOnRouteAndTimeRequest {
	return ApiLockActivityOnRouteAndTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) LockActivityOnRouteAndTimeExecute(r ApiLockActivityOnRouteAndTimeRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.LockActivityOnRouteAndTime")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/lock-on-route-and-time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.filters == nil {
		executionError.error = "filters is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiRetrieveActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	activityId int64
	includeActivityStatus *bool
	includeActivityTypeName *bool
	includeActivityMetaData *bool
	includeAddressObject *bool
	includeTimeSlots *bool
	includeRouteInfo *bool
	includeRoute *bool
	includePackageLines *bool
	includePackageLinesInfo *bool
	includeDriverInfo *bool
	includeCommunication *bool
	includeCommunicationObject *bool
	includeActivityLinks *bool
	includeActivityFiles *bool
	includeActivityFilesMetaData *bool
	includeAssignmentNr *bool
	includeAssignment *bool
	includeActivityTags *bool
	includeTagTypeName *bool
	includeActivityRecordInfo *bool
	includeActivityNotes *bool
	includeActivityNoteTags *bool
	includeDepotAddressObject *bool
	includeCapacityObject *bool
	includeZones *bool
	includeBrand *bool
	includeBrandColours *bool
	includeBrandFiles *bool
	includeRelations *bool
}

func (r ApiRetrieveActivityRequest) IncludeActivityStatus(includeActivityStatus bool) ApiRetrieveActivityRequest {
	r.includeActivityStatus = &includeActivityStatus
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityTypeName(includeActivityTypeName bool) ApiRetrieveActivityRequest {
	r.includeActivityTypeName = &includeActivityTypeName
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityMetaData(includeActivityMetaData bool) ApiRetrieveActivityRequest {
	r.includeActivityMetaData = &includeActivityMetaData
	return r
}
func (r ApiRetrieveActivityRequest) IncludeAddressObject(includeAddressObject bool) ApiRetrieveActivityRequest {
	r.includeAddressObject = &includeAddressObject
	return r
}
func (r ApiRetrieveActivityRequest) IncludeTimeSlots(includeTimeSlots bool) ApiRetrieveActivityRequest {
	r.includeTimeSlots = &includeTimeSlots
	return r
}
func (r ApiRetrieveActivityRequest) IncludeRouteInfo(includeRouteInfo bool) ApiRetrieveActivityRequest {
	r.includeRouteInfo = &includeRouteInfo
	return r
}
func (r ApiRetrieveActivityRequest) IncludeRoute(includeRoute bool) ApiRetrieveActivityRequest {
	r.includeRoute = &includeRoute
	return r
}
func (r ApiRetrieveActivityRequest) IncludePackageLines(includePackageLines bool) ApiRetrieveActivityRequest {
	r.includePackageLines = &includePackageLines
	return r
}
func (r ApiRetrieveActivityRequest) IncludePackageLinesInfo(includePackageLinesInfo bool) ApiRetrieveActivityRequest {
	r.includePackageLinesInfo = &includePackageLinesInfo
	return r
}
func (r ApiRetrieveActivityRequest) IncludeDriverInfo(includeDriverInfo bool) ApiRetrieveActivityRequest {
	r.includeDriverInfo = &includeDriverInfo
	return r
}
func (r ApiRetrieveActivityRequest) IncludeCommunication(includeCommunication bool) ApiRetrieveActivityRequest {
	r.includeCommunication = &includeCommunication
	return r
}
func (r ApiRetrieveActivityRequest) IncludeCommunicationObject(includeCommunicationObject bool) ApiRetrieveActivityRequest {
	r.includeCommunicationObject = &includeCommunicationObject
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityLinks(includeActivityLinks bool) ApiRetrieveActivityRequest {
	r.includeActivityLinks = &includeActivityLinks
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityFiles(includeActivityFiles bool) ApiRetrieveActivityRequest {
	r.includeActivityFiles = &includeActivityFiles
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityFilesMetaData(includeActivityFilesMetaData bool) ApiRetrieveActivityRequest {
	r.includeActivityFilesMetaData = &includeActivityFilesMetaData
	return r
}
func (r ApiRetrieveActivityRequest) IncludeAssignmentNr(includeAssignmentNr bool) ApiRetrieveActivityRequest {
	r.includeAssignmentNr = &includeAssignmentNr
	return r
}
func (r ApiRetrieveActivityRequest) IncludeAssignment(includeAssignment bool) ApiRetrieveActivityRequest {
	r.includeAssignment = &includeAssignment
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityTags(includeActivityTags bool) ApiRetrieveActivityRequest {
	r.includeActivityTags = &includeActivityTags
	return r
}
func (r ApiRetrieveActivityRequest) IncludeTagTypeName(includeTagTypeName bool) ApiRetrieveActivityRequest {
	r.includeTagTypeName = &includeTagTypeName
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityRecordInfo(includeActivityRecordInfo bool) ApiRetrieveActivityRequest {
	r.includeActivityRecordInfo = &includeActivityRecordInfo
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityNotes(includeActivityNotes bool) ApiRetrieveActivityRequest {
	r.includeActivityNotes = &includeActivityNotes
	return r
}
func (r ApiRetrieveActivityRequest) IncludeActivityNoteTags(includeActivityNoteTags bool) ApiRetrieveActivityRequest {
	r.includeActivityNoteTags = &includeActivityNoteTags
	return r
}
func (r ApiRetrieveActivityRequest) IncludeDepotAddressObject(includeDepotAddressObject bool) ApiRetrieveActivityRequest {
	r.includeDepotAddressObject = &includeDepotAddressObject
	return r
}
func (r ApiRetrieveActivityRequest) IncludeCapacityObject(includeCapacityObject bool) ApiRetrieveActivityRequest {
	r.includeCapacityObject = &includeCapacityObject
	return r
}
func (r ApiRetrieveActivityRequest) IncludeZones(includeZones bool) ApiRetrieveActivityRequest {
	r.includeZones = &includeZones
	return r
}
func (r ApiRetrieveActivityRequest) IncludeBrand(includeBrand bool) ApiRetrieveActivityRequest {
	r.includeBrand = &includeBrand
	return r
}
func (r ApiRetrieveActivityRequest) IncludeBrandColours(includeBrandColours bool) ApiRetrieveActivityRequest {
	r.includeBrandColours = &includeBrandColours
	return r
}
func (r ApiRetrieveActivityRequest) IncludeBrandFiles(includeBrandFiles bool) ApiRetrieveActivityRequest {
	r.includeBrandFiles = &includeBrandFiles
	return r
}
func (r ApiRetrieveActivityRequest) IncludeRelations(includeRelations bool) ApiRetrieveActivityRequest {
	r.includeRelations = &includeRelations
	return r
}

func (r ApiRetrieveActivityRequest) Execute() (ActivityModel, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.RetrieveActivityExecute(r)
}

/*
 * RetrieveActivity Find activity by ID
 * Returns a single activity
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activityId ID of activity to return
 * @return ApiRetrieveActivityRequest
 */
func (a *ActivityApiService) RetrieveActivity(ctx _context.Context, activityId int64) ApiRetrieveActivityRequest {
	return ApiRetrieveActivityRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
	}
}

/*
 * Execute executes the request
 * @return ActivityModel
 */
func (a *ActivityApiService) RetrieveActivityExecute(r ApiRetrieveActivityRequest) (ActivityModel, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ActivityModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.RetrieveActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", _neturl.PathEscape(parameterToString(r.activityId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.includeActivityStatus == nil {
		executionError.error = "includeActivityStatus is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityTypeName == nil {
		executionError.error = "includeActivityTypeName is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityMetaData == nil {
		executionError.error = "includeActivityMetaData is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeAddressObject == nil {
		executionError.error = "includeAddressObject is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeTimeSlots == nil {
		executionError.error = "includeTimeSlots is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeRouteInfo == nil {
		executionError.error = "includeRouteInfo is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeRoute == nil {
		executionError.error = "includeRoute is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includePackageLines == nil {
		executionError.error = "includePackageLines is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includePackageLinesInfo == nil {
		executionError.error = "includePackageLinesInfo is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeDriverInfo == nil {
		executionError.error = "includeDriverInfo is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeCommunication == nil {
		executionError.error = "includeCommunication is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeCommunicationObject == nil {
		executionError.error = "includeCommunicationObject is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityLinks == nil {
		executionError.error = "includeActivityLinks is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityFiles == nil {
		executionError.error = "includeActivityFiles is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityFilesMetaData == nil {
		executionError.error = "includeActivityFilesMetaData is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeAssignmentNr == nil {
		executionError.error = "includeAssignmentNr is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeAssignment == nil {
		executionError.error = "includeAssignment is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityTags == nil {
		executionError.error = "includeActivityTags is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeTagTypeName == nil {
		executionError.error = "includeTagTypeName is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityRecordInfo == nil {
		executionError.error = "includeActivityRecordInfo is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityNotes == nil {
		executionError.error = "includeActivityNotes is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeActivityNoteTags == nil {
		executionError.error = "includeActivityNoteTags is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeDepotAddressObject == nil {
		executionError.error = "includeDepotAddressObject is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeCapacityObject == nil {
		executionError.error = "includeCapacityObject is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeZones == nil {
		executionError.error = "includeZones is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeBrand == nil {
		executionError.error = "includeBrand is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeBrandColours == nil {
		executionError.error = "includeBrandColours is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeBrandFiles == nil {
		executionError.error = "includeBrandFiles is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.includeRelations == nil {
		executionError.error = "includeRelations is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("include_activity_status", parameterToString(*r.includeActivityStatus, ""))
	localVarQueryParams.Add("include_activity_type_name", parameterToString(*r.includeActivityTypeName, ""))
	localVarQueryParams.Add("include_activity_meta_data", parameterToString(*r.includeActivityMetaData, ""))
	localVarQueryParams.Add("include_address_object", parameterToString(*r.includeAddressObject, ""))
	localVarQueryParams.Add("include_time_slots", parameterToString(*r.includeTimeSlots, ""))
	localVarQueryParams.Add("include_route_info", parameterToString(*r.includeRouteInfo, ""))
	localVarQueryParams.Add("include_route", parameterToString(*r.includeRoute, ""))
	localVarQueryParams.Add("include_package_lines", parameterToString(*r.includePackageLines, ""))
	localVarQueryParams.Add("include_package_lines_info", parameterToString(*r.includePackageLinesInfo, ""))
	localVarQueryParams.Add("include_driver_info", parameterToString(*r.includeDriverInfo, ""))
	localVarQueryParams.Add("include_communication", parameterToString(*r.includeCommunication, ""))
	localVarQueryParams.Add("include_communication_object", parameterToString(*r.includeCommunicationObject, ""))
	localVarQueryParams.Add("include_activity_links", parameterToString(*r.includeActivityLinks, ""))
	localVarQueryParams.Add("include_activity_files", parameterToString(*r.includeActivityFiles, ""))
	localVarQueryParams.Add("include_activity_files_meta_data", parameterToString(*r.includeActivityFilesMetaData, ""))
	localVarQueryParams.Add("include_assignment_nr", parameterToString(*r.includeAssignmentNr, ""))
	localVarQueryParams.Add("include_assignment", parameterToString(*r.includeAssignment, ""))
	localVarQueryParams.Add("include_activity_tags", parameterToString(*r.includeActivityTags, ""))
	localVarQueryParams.Add("include_tag_type_name", parameterToString(*r.includeTagTypeName, ""))
	localVarQueryParams.Add("include_activity_record_info", parameterToString(*r.includeActivityRecordInfo, ""))
	localVarQueryParams.Add("include_activity_notes", parameterToString(*r.includeActivityNotes, ""))
	localVarQueryParams.Add("include_activity_note_tags", parameterToString(*r.includeActivityNoteTags, ""))
	localVarQueryParams.Add("include_depot_address_object", parameterToString(*r.includeDepotAddressObject, ""))
	localVarQueryParams.Add("include_capacity_object", parameterToString(*r.includeCapacityObject, ""))
	localVarQueryParams.Add("include_zones", parameterToString(*r.includeZones, ""))
	localVarQueryParams.Add("include_brand", parameterToString(*r.includeBrand, ""))
	localVarQueryParams.Add("include_brand_colours", parameterToString(*r.includeBrandColours, ""))
	localVarQueryParams.Add("include_brand_files", parameterToString(*r.includeBrandFiles, ""))
	localVarQueryParams.Add("include_relations", parameterToString(*r.includeRelations, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiRetrieveListActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	arguments *ActivityRetrieveListArguments
}

func (r ApiRetrieveListActivityRequest) Arguments(arguments ActivityRetrieveListArguments) ApiRetrieveListActivityRequest {
	r.arguments = &arguments
	return r
}

func (r ApiRetrieveListActivityRequest) Execute() (ActivityListResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.RetrieveListActivityExecute(r)
}

/*
 * RetrieveListActivity Retrieve List of Activities
 * Retrieve List of Activities
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRetrieveListActivityRequest
 */
func (a *ActivityApiService) RetrieveListActivity(ctx _context.Context) ApiRetrieveListActivityRequest {
	return ApiRetrieveListActivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ActivityListResponse
 */
func (a *ActivityApiService) RetrieveListActivityExecute(r ApiRetrieveListActivityRequest) (ActivityListResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ActivityListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.RetrieveListActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.arguments == nil {
		executionError.error = "arguments is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.arguments
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiSetActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	body *ActivityModel
}

func (r ApiSetActivityRequest) Body(body ActivityModel) ApiSetActivityRequest {
	r.body = &body
	return r
}

func (r ApiSetActivityRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.SetActivityExecute(r)
}

/*
 * SetActivity Set (create or update) an Activity
 * Set (create or update) an Activity. If id or links are set in the data, and a corresponding activity is found in Bumbal, an update will be performed.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSetActivityRequest
 */
func (a *ActivityApiService) SetActivity(ctx _context.Context) ApiSetActivityRequest {
	return ApiSetActivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) SetActivityExecute(r ApiSetActivityRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.SetActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiUnlockActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	filters *ActivityFiltersModel
}

func (r ApiUnlockActivityRequest) Filters(filters ActivityFiltersModel) ApiUnlockActivityRequest {
	r.filters = &filters
	return r
}

func (r ApiUnlockActivityRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.UnlockActivityExecute(r)
}

/*
 * UnlockActivity Unlock activities which satisfy set filters
 * Unlock activities which satisfy set filters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUnlockActivityRequest
 */
func (a *ActivityApiService) UnlockActivity(ctx _context.Context) ApiUnlockActivityRequest {
	return ApiUnlockActivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) UnlockActivityExecute(r ApiUnlockActivityRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.UnlockActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/unlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.filters == nil {
		executionError.error = "filters is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filters
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiUnsuccessfulRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	arguments *UnsuccessfulModel
}

func (r ApiUnsuccessfulRequest) Arguments(arguments UnsuccessfulModel) ApiUnsuccessfulRequest {
	r.arguments = &arguments
	return r
}

func (r ApiUnsuccessfulRequest) Execute() (UnsuccessfulResponseModel, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.UnsuccessfulExecute(r)
}

/*
 * Unsuccessful Report an unsuccessful activity
 * Report an unsuccessful activity
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUnsuccessfulRequest
 */
func (a *ActivityApiService) Unsuccessful(ctx _context.Context) ApiUnsuccessfulRequest {
	return ApiUnsuccessfulRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return UnsuccessfulResponseModel
 */
func (a *ActivityApiService) UnsuccessfulExecute(r ApiUnsuccessfulRequest) (UnsuccessfulResponseModel, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  UnsuccessfulResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.Unsuccessful")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/unsuccessful"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.arguments == nil {
		executionError.error = "arguments is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.arguments
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiUpdateActivityRequest struct {
	ctx _context.Context
	ApiService *ActivityApiService
	activityId int64
	body *ActivityModel
}

func (r ApiUpdateActivityRequest) Body(body ActivityModel) ApiUpdateActivityRequest {
	r.body = &body
	return r
}

func (r ApiUpdateActivityRequest) Execute() (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.UpdateActivityExecute(r)
}

/*
 * UpdateActivity Update a activity
 * Update a activity
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activityId ID of activity to update
 * @return ApiUpdateActivityRequest
 */
func (a *ActivityApiService) UpdateActivity(ctx _context.Context, activityId int64) ApiUpdateActivityRequest {
	return ApiUpdateActivityRequest{
		ApiService: a,
		ctx: ctx,
		activityId: activityId,
	}
}

/*
 * Execute executes the request
 * @return ApiResponse
 */
func (a *ActivityApiService) UpdateActivityExecute(r ApiUpdateActivityRequest) (ApiResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivityApiService.UpdateActivity")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/activity/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", _neturl.PathEscape(parameterToString(r.activityId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwt"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}
