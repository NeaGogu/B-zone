package main

import (
	"encoding/json"
	"fmt"
	"github.com/go-chi/chi/middleware"
	"github.com/go-chi/chi/v5"
	"io"
	"net/http"
	"os"
)

func hello(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Hello brothers!"))
}

func getAreaPoint(w http.ResponseWriter, r *http.Request) {

	type Codes struct {
		Pc4         string `json:"pc4"`
		Coordinates any    `json:"coordinates"`
	}

	type Nl struct {
		Nl []Codes `json:"nl"`
	}

	type CodesRequested struct {
		Pc4_Codes []string `json:"pc4"`
	}

	var path = "./data/nlnasty.json"
	jsonNl, err := os.Open(path)

	if err != nil {
		fmt.Println(err)
		panic(err.Error())
	}

	fmt.Println("Successfully Opened newnl.json")
	defer jsonNl.Close()

	byteValue, err := io.ReadAll(jsonNl)
	if err != nil {
		fmt.Println(err.Error())
		panic(err.Error())
	}

	var nl Nl

	err = json.Unmarshal(byteValue, &nl)
	if err != nil {
		fmt.Println(err.Error())
		panic("unmarshal")
	}

	//var reqCode Codes
	//err = json.NewDecoder(r.Body).Decode(&reqCode)
	//
	//if err != nil {
	//	http.Error(w, err.Error(), http.StatusBadRequest)
	//	return
	//}
	//
	//pc4 := reqCode.Pc4

	var reqCode CodesRequested
	err = json.NewDecoder(r.Body).Decode(&reqCode)

	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	pc4 := reqCode.Pc4_Codes
	checkZipcodes := []string{}

	var found bool
	var testCode string

	for i := 0; i < len(pc4); i++ {
		found = false
		testCode = pc4[i]

		for i := 0; i < len(nl.Nl); i++ {
			if nl.Nl[i].Pc4 == testCode {
				found = true
			}
		}

		if found == false {
			checkZipcodes = append(checkZipcodes, testCode)
		}
	}

	if len(checkZipcodes) > 0 {
		json.NewEncoder(w).Encode(append(checkZipcodes, "not in the dataset"))
		return
	}

	coordinates := []any{}

	for i := 0; i < len(nl.Nl); i++ {
		for _, zipcode := range pc4 {
			if nl.Nl[i].Pc4 == zipcode {
				//fmt.Println(nl.Nl[i].Coordinates)
				coordinates = append(coordinates, nl.Nl[i].Coordinates)
				w.WriteHeader(http.StatusOK)
				fmt.Println("Clone Force 99")
				//json.NewEncoder(w).Encode(nl.Nl[i].Coordinates)
				//return
			}
		}

		//if nl.Nl[i].Pc4 == pc4 {
		//	fmt.Println(nl.Nl[i].Coordinates)
		//	w.WriteHeader(http.StatusOK)
		//	json.NewEncoder(w).Encode(nl.Nl[i].Coordinates)
		//	return
		//}
	}

	json.NewEncoder(w).Encode(coordinates)
	fmt.Println("Clone Force 99 again")

	w.WriteHeader(http.StatusNotFound)
	return
}

func (app *application) routes() http.Handler {
	// init the router
	router := chi.NewRouter()

	// TODO
	// router.NotFound()

	// A good base middleware stack
	router.Use(middleware.RequestID)
	router.Use(middleware.RealIP)
	router.Use(middleware.Logger)
	router.Use(middleware.Recoverer)

	router.Route("/test_route", func(r chi.Router) {
		r.Get("/", hello)
	})

	router.Route("/zip", func(r chi.Router) {
		r.Get("/area_points", getAreaPoint)
	})

	return router
}

//package main
//
//import (
//	"encoding/json"
//	"fmt"
//	"io"
//	"net/http"
//	"os"
//
//	"github.com/go-chi/chi/middleware"
//	"github.com/go-chi/chi/v5"
//)
//
//func hello(w http.ResponseWriter, r *http.Request) {
//	w.Write([]byte("Hello brothers!"))
//}
//
//type Codes struct {
//	Pc4         string        `json:"pc4"`
//	Coordinates [][][]float64 `json:"coordinates"`
//}
//
//type Nl struct {
//	Nl []AutoGenerated `json:"nl"`
//}
//
//type TestStruct [][][]float64
//
//type AutoGenerated struct {
//	Geometry struct {
//		Coordinates any    `json:"coordinates"`
//		Type        string `json:"type"`
//	} `json:"geometry"`
//	Properties struct {
//		GemCode    string `json:"gem_code"`
//		GemName    string `json:"gem_name"`
//		GeoPoint2D struct {
//			Lat float64 `json:"lat"`
//			Lon float64 `json:"lon"`
//		} `json:"geo_point_2d"`
//		Pc4Code  string `json:"pc4_code"`
//		ProvCode string `json:"prov_code"`
//		ProvName string `json:"prov_name"`
//		Year     string `json:"year"`
//	} `json:"properties"`
//	Type string `json:"type"`
//}
//
//func parseZipFile(path string) {
//	jsonNl, err := os.Open(path)
//
//	if err != nil {
//		fmt.Println(err)
//		panic(err.Error())
//	}
//
//	fmt.Println("Successfully Opened newnl.json")
//	defer jsonNl.Close()
//
//	byteValue, err := io.ReadAll(jsonNl)
//	if err != nil {
//		fmt.Println(err.Error())
//		panic(err.Error())
//	}
//
//	var nl Nl
//
//	err = json.Unmarshal(byteValue, &nl)
//	if err != nil {
//		fmt.Println(err.Error())
//		panic("unmarshal")
//	}
//
//	fmt.Println(nl.Nl[0].Geometry.Coordinates)
//	for _, j := range nl.Nl {
//		fmt.Printf("trying %v", j.Properties.Pc4Code)
//		_ = (j.Geometry.Coordinates).(TestStruct)
//	}
//
//}
//
////func getAreaPoint(w http.ResponseWriter, r *http.Request) {
////
////	var reqCode Codes
////	err := json.NewDecoder(r.Body).Decode(&reqCode)
////
////	if err != nil {
////		http.Error(w, err.Error(), http.StatusBadRequest)
////		return
////	}
////
////	pc4 := reqCode.Pc4
////
////	for i := 0; i < len(nl.Nl); i++ {
////		if nl.Nl[i].Pc4 == pc4 {
////			fmt.Println(nl.Nl[i].Coordinates)
////			w.WriteHeader(http.StatusOK)
////			json.NewEncoder(w).Encode(nl.Nl[i].Coordinates)
////			return
////		}
////	}
////
////	w.WriteHeader(http.StatusNotFound)
////	return
////}
//
//func (app *application) routes() http.Handler {
//	// init the router
//	router := chi.NewRouter()
//
//	// TODO
//	// router.NotFound()
//
//	// A good base middleware stack
//	router.Use(middleware.RequestID)
//	router.Use(middleware.RealIP)
//	router.Use(middleware.Logger)
//	router.Use(middleware.Recoverer)
//
//	router.Route("/test_route", func(r chi.Router) {
//		r.Get("/", hello)
//	})
//
//	router.Route("/zip", func(r chi.Router) {
//		r.Get("/area_points", hello)
//	})
//
//	return router
//}
